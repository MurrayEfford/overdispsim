---
title: '**overdispsim** - Simulations of Overdispersion in SECR'
author: "Murray Efford and David Fletcher"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    toc_depth: 2
vignette: > 
  %\VignetteIndexEntry{Simulations of Overdispersion in SECR} 
  %\VignetteEngine{knitr::rmarkdown} 
  \usepackage[utf8]{inputenc} 
---

# Introduction

This vignette explains the functions in the package **overdispsim** and 
provides code for simulations in the paper of Efford and Fletcher (2023). 

**overdispsim** uses the R packages **secr** (Efford 2023a) and 
**secrdesign** (Efford 2023b) available from the CRAN repository. 

Three processes are simulated for the distribution of activity centres (AC): a log-Gaussian Cox process (LGCP), a Thomas cluster process and a random binary habitat mosaic.

Functions `rLGCP` and `rThomas` from the **spatstat** package (Baddeley et al. 2015) are used where possible. However, simulations conditional on $N(A)$ (the fixed number in buffered area $A$) required custom code for LGCP (the exported function `myRF`), and the fixed cluster process of Bischof et al. (2020) was emulated using the **secr** function `sim.popn` with settings model2D = "cluster" and details$clone = "constant" (see below.)

Package RandomFields (Schlather et al. 2015) is required for LGCP simulations 
with both `rLGCP` and `spatstat`. 

# Setup

```{r setup}
library(overdispsim, quietly = TRUE)
options(digits = 5)

# Assign variables to an environment that is available to other 
# functions in the package. 

local <- setlocalparameters(
	lambda0     = 0.5,
	sigma       = 1.0,
	noccasions  = 5,
	traps       = make.grid(12,12, detector = 'proximity', spacing = 2.0),
	maskspacing = 0.5,
	maskbuffer  = 4,
	N           = 256,
	maxncores   = 18
)
```

# Interesting derived quantities

```{r derived}

# expected variance of binomial n
pd <- pdot(local$mask, local$traps, detectfn = 'HHN', 
 		   detectpar = local$detectpar, noccasions = local$noccasions)
a <- sum(pd * attr(local$mask, 'area'))
p <- a / maskarea(local$mask)
Evarn <- p * (1-p) * local$N

# expected number of individuals detected
En <- sum(pd) * attr(local$mask, 'area') * local$D

# expected number of individuals at each detector
enk <- Enk(D = local$D, local$mask, local$traps, detectfn = 'HHN',
		   detectpar = local$detectpar, noccasions = local$noccasions)
```

# Define populations

Start by specifying some vectors with varying levels of parameters:
```{r levels}
Alevels  <- c(0.0625, 0.125, 0.25, 0.5, 0.75, 1.0) # randomHabitat A
Vlevels  <- c(0, 0.125, 0.25, 0.5, 0.75, 1.0)      # LGCP variances
mulevels <- c(1,2,4,8,16,32)                       # expected number per cluster   
```
## Poisson N(A)

```{r definepop}
# LGCP
basepopargs1 <- list(
	D = local$D, 
	core = local$mask,
	buffer = 0,    # uses bounding box of mask
	model2D = "rLGCP",
	details = list(var = 0, scale = 5 * local$sigma, eps = spacing(local$mask), 
				   saveLambda = TRUE))
popargs1 <- extend(basepopargs1, values = list(var = Vlevels, scale = c(5,10) * local$sigma))
#-------------------------------------------------------------------------------

# Thomas clustering
basepopargs2 <- list(D = local$D, 
					 core = local$mask,
					 buffer = spacing(local$mask)/2,
					 model2D = "rThomas",
					 details = list(mu = 1, scale = local$sigma, eps = 
					 			   	spacing(local$mask), saveLambda = TRUE))
# rThomas requires scale>0
popargs2 <- extend(basepopargs2, values = list(mu = mulevels, scale = c(1e-4, 1, 2, 4)*local$sigma))

#-------------------------------------------------------------------------------

# random habitat 
basepopargs3 <- list(D = randomDensity, 
					 core = local$mask,
					 buffer = 0,
					 model2D = "IHP",
					 details = list(D = D, p=0.5, A=0.25, rescale=TRUE))
popargs3 <- extend(basepopargs3, values = list(A = Alevels, p = c(0.25, 0.5)) )
```

## Fixed N(A)

```{r definepopfixed}

# random field
basepopargs1f <- list(
	D = myRF, 
	core = local$mask,
	buffer = 0,
	model2D = "IHP",
	Ndist   = "fixed",
	Nbuffer = local$N,
	details = list(var = 1, scale = 1, N = local$N, eps = spacing(local$mask), 
				   saveLambda = TRUE))
popargs1f <- extend(basepopargs1f, values = list(var = Vlevels, scale = c(5,10) * local$sigma))
#-------------------------------------------------------------------------------

# Clusters (constant size)
# no algorithm for fixed-N rThomas?
# cf Bischof et al. fixed clusters (clone = "constant", scale = 0)

basepopargs2f <- list(D = local$D, 
					  core = local$mask,
					  buffer = spacing(local$mask)/2,
					  model2D = "cluster",
					  Ndist   = "fixed",
					  Nbuffer = local$N,
					  details = list(mu = 1, scale = 1, clone = "constant",
					  	eps = spacing(local$mask), saveLambda = TRUE))
popargs2f <- extend(basepopargs2f, values = list(mu = mulevels, scale = c(0,1,2,4)*local$sigma))
#-------------------------------------------------------------------------------

# random habitat, fixed-N
basepopargs3f <- list(D      = randomDensity, 
					  core    = local$mask,
					  buffer  = 0,
					  model2D = "IHP",
					  Ndist   = "fixed",
					  Nbuffer = local$N,
					  details = list(D = D, p=0.5, A=0.25, rescale=TRUE))
popargs3f <- extend(basepopargs3f, values = list(A = Alevels, p = c(0.25, 0.5)) )
```

# Example

Select a subset of cluster (Thomas process) population scenarios and extract the parameter levels for later use. 
```{r pops}
sapply(popargs2, '[[', 'details')[1:2,]  # display parameter values
pops <- popargs2[13:18]                  # select mu = 1..32, scale = 2
```

And plot an example with mu = 32 and scale = 2:
```{r pop plot}
set.seed(12345)
pop <- do.call(sim.popn, popargs2[[18]])
plot(pop)                   # AC
plot(local$traps, add = TRUE)   # detectors
```

## No model fit

[Messages are suppressed.]

```{r example1, message = FALSE, cache = TRUE}
sims <- run_all(nrepl = 100, pops, fit = FALSE)
sumn <- summary_n(sims)
sumn[,1:10]
```

## Model fit

Using the same population scenarios -
```{r example2, message = FALSE, cache = TRUE, warning = FALSE}
simsM <- run_all(nrepl = 10, pops, fit = TRUE)  
summary_M(simsM)                     
```

# Code for simulations in paper

Here we list the commands used to generate the main results. Each of these takes substantial time to run (hours). They should be run separately and saved for later processing (i.e. summary).

| Code | AC distribution | Fit | extractfn | Note |
-----|-----------|-----------|-----------|-----------------
1 | LGCP | none | extract_n |
2 | Thomas process | none |extract_n |
3 | random habitat | none |extract_n |
1f | fixed-N(A) LGCP | none |extract_n |
2f | fixed cluster process | none |extract_n |
3f | fixed-N(A) random habitat | none |extract_n |
1M | LGCP | full likelihood | extract_M |
2M | Thomas process | full likelihood |  extract_M |
3M | random habitat | full likelihood | extract_M |
1Mf | fixed-N(A) LGCP | full likelihood | extract_M |
2Mf | fixed cluster process | full likelihood | extract_M |
3Mf | fixed-N(A) random habitat | full likelihood | extract_M |
1MCL | LGCP | conditional likelihood | extract_MCL |
2MCL | Thomas process | conditional likelihood |  extract_MCL |
3MCL | random habitat | conditional likelihood | extract_MCL |

## Sampling only

Here we generate SECR samples, count the number of detected individuals $n$ and 
compute $\hat c$ using the known detection parameters. Models are not fitted.

```{r samplingonly, eval = FALSE}

nrepl <- 10000

# Poisson N(A)
sims1 <- run_all(nrepl, popargs1, fit = FALSE, byscenario = FALSE)
sims2 <- run_all(nrepl, popargs2, fit = FALSE, byscenario = TRUE)
sims3 <- run_all(nrepl, popargs3, fit = FALSE, byscenario = TRUE)

# Fixed N(A)
sims1f <- run_all(nrepl, popargs1f, fit = FALSE, byscenario = FALSE)
# byscenarios = TRUE throws error
sims2f <- run_all(nrepl, popargs2f, fit = FALSE, byscenario = TRUE)
sims3f <- run_all(nrepl, popargs3f, fit = FALSE, byscenario = TRUE)
```

## Full model fits (suffix M)

```{r modelfits, eval = FALSE}

nreplM <- 1000

# Poisson N(A)
sims1M <- run_all(nreplM, popargs1[7:12],  fit = TRUE)
sims2M <- run_all(nreplM, popargs2[13:18], fit = TRUE, 
			  start = list(D = 3000, lambda0 = 0.4, sigma = 2.2))
sims3M <- run_all(nreplM, popargs3[7:12], fit = TRUE)

# Fixed N(A)
sims1fM <- run_all(nreplM, popargs1f[7:12], fit = TRUE, distribution = "binomial", 
			   start = list(D = 5000))
sims3fM <- run_all(nreplM, popargs3f[7:12], fit = TRUE, distribution = "binomial")
sims2fM <- run_all(nreplM, popargs2f[7:12], fit = TRUE, distribution = "binomial")
```
## Summaries

```{r load, eval = TRUE, echo = FALSE}
matrixfolder <- 'd:/density communication/overdispersion/matrix/'

load(file = paste0(matrixfolder, 'sims1.RData'))
load(file = paste0(matrixfolder, 'sims2.RData'))
load(file = paste0(matrixfolder, 'sims3.RData'))

load(file = paste0(matrixfolder, 'sims1f.RData'))
load(file = paste0(matrixfolder, 'sims2f.RData'))
load(file = paste0(matrixfolder, 'sims3f.RData'))

load(file = paste0(matrixfolder, 'sims1M.RData'))
load(file = paste0(matrixfolder, 'sims2M.RData'))
load(file = paste0(matrixfolder, 'sims3M.RData'))
load(file = paste0(matrixfolder, 'sims1fM.RData'))
load(file = paste0(matrixfolder, 'sims2fM.RData'))
load(file = paste0(matrixfolder, 'sims3fM.RData'))

load(file = paste0(matrixfolder, 'sims1MCL.RData'))
load(file = paste0(matrixfolder, 'sims2MCL.RData'))
load(file = paste0(matrixfolder, 'sims3MCL.RData'))

load(file = paste0(matrixfolder, 'sims2CCL.RData'))   # cohesion
load(file = paste0(matrixfolder, 'sims2CfCL.RData'))  # cohesion, fixed N(A)
```

```{r summaryM, eval = FALSE}

# no fit
sum1  <- summary_n(sims1) 
sum2  <- summary_n(sims2)
sum3  <- summary_n(sims3)
sum1f  <- summary_n(sims1f) 
sum2f  <- summary_n(sims2f)
sum3f  <- summary_n(sims3f)

# vs detection-weighted local density
sum1M  <- summary_M(sims1M) 
sum2M  <- summary_M(sims2M)
sum3M  <- summary_M(sims3M)

# vs global density
sum1MT <- summary_M(sims1M, true = 2844.44)  
sum2MT <- summary_M(sims2M, true = 2844.44)  
sum3MT <- summary_M(sims3M, true = 2844.44)  

# conditional likelihood (for COV(a) etc.)
sum1MCL <- summary_MCL(sims1MCL, true = 2844.44)  
sum2MCL <- summary_MCL(sims2MCL, true = 2844.44)  
sum3MCL <- summary_MCL(sims3MCL, true = 2844.44)  

```

```{r savesummary, echo = FALSE, eval = FALSE}
# save summaries to data folder

# no fit
save(sum1, file = 'data/sum1.RData')
save(sum2, file = 'data/sum2.RData')
save(sum3, file = 'data/sum3.RData')

# no fit, fixed
save(sum1f, file = 'data/sum1f.RData')
save(sum2f, file = 'data/sum2f.RData')
save(sum3f, file = 'data/sum3f.RData')

# vs detection-weighted local density
save(sum1M, file = 'data/sum1M.RData')
save(sum2M, file = 'data/sum2M.RData')
save(sum3M, file = 'data/sum3M.RData')

# vs global density
save(sum1MT, file = 'data/sum1MT.RData')
save(sum2MT, file = 'data/sum2MT.RData')
save(sum3MT, file = 'data/sum3MT.RData')

# conditional likelihood (for COV(a) etc.)
save(sum1MCL, file = 'data/sum1MCL.RData')
save(sum2MCL, file = 'data/sum2MCL.RData')
save(sum3MCL, file = 'data/sum3MCL.RData')

```

```{r csv, eval = FALSE, echo = FALSE}
write.csv(sum1M, file='extra/sum1M.csv')
write.csv(sum2M, file='extra/sum2M.csv')
write.csv(sum3M, file='extra/sum3M.csv')

write.csv(sum1MT, file='extra/sum1MT.csv')
write.csv(sum2MT, file='extra/sum2MT.csv')
write.csv(sum3MT, file='extra/sum3MT.csv')

write.csv(sum1MCL, file='extra/sum1MCL.csv')
write.csv(sum2MCL, file='extra/sum2MCL.csv')
write.csv(sum3MCL, file='extra/sum3MCL.csv')
```

# CL

The SECR model was fitted by maximising the conditional likelihood as a convenient way to simulate the coverage of confidence intervals for the effective sampling area $a(\hat \theta)$ and the proportion of variance due to $n$ and $a(\hat \theta)$.

```{r CLfit, eval = FALSE}
# Poisson N
sims1MCL <- run_all(1000, popargs1[7:12], fit = TRUE, CL = TRUE)
sims2MCL <- run_all(1000, popargs2[13:18], fit = TRUE, CL = TRUE, 
				 start = list(D = 3000, lambda0 = 0.4, sigma = 2.2))
sims3MCL <- run_all(1000, popargs3[7:12], fit = TRUE, CL = TRUE)
```

# Cohesion

Additional simulations were performed with overdispersion in the detection process. A novel function (`sim.capthist`) is defined for simulating detection with variable within-cluster cohesion, ranging from none (gamma = 0) to complete (gamma = 1). This applies *only* to clustered AC.

```{r cohesion, eval = FALSE}
detargs <- list (savepopn = TRUE, gamma = 1)  # complete cohesion
# No fit
sims2C <- run_all(10000, popargs2, CH.function = "sim.cohesion", detargs = detargs,
			   fit = FALSE, byscenario = TRUE)
sims2Cf <- run_all(10000, popargs2f, CH.function = "sim.cohesion", detargs = detargs,
			   fit = FALSE, byscenario = TRUE)
# Conditional likelihood fit (effect of cohesion on coverage of $\hat a$)
sims2CCL <- run_all(1000, popargs2[1:6], CH.function = "sim.cohesion", detargs = detargs,
			   fit = TRUE, CL = TRUE, byscenario = FALSE)
sims2CfCL <- run_all(1000, popargs2f[1:6], CH.function = "sim.cohesion", detargs = detargs,
				fit = TRUE, CL = TRUE, byscenario = FALSE)
```

```{r cohesion1, eval = FALSE, echo = FALSE}
sum2CCL <- summary_MCL(sims2CCL, true = 2844.44)
sum2CfCL <- summary_MCL(sims2CfCL, true = 2844.44) 
```

# References

Baddeley, A., Rubak, E., and Turner, R. (2015) *Spatial Point Patterns: Methodology and Applications with R*. Chapman and Hall/CRC Press, London.

Bischof, R., Dupont, P., Milleret, C., Chipperfield, J., and Royle, J. A. (2020) Consequences of ignoring group association in spatial capture--recapture analysis. *Wildlife Biology* wlb.00649. DOI 10.2981/wlb.00649

Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum likelihood methods for capture--recapture studies. *Biometrics* **64**, 377--385.

Efford, M. G. (2023a) secr: Spatially explicit capture--recapture models. R package version
  4.6.4. https://CRAN.R-project.org/package=secr/
  
Efford, M. G. (2023b) openCR: Spatially explicit capture--recapture models. R package version
  2.2.6. https://CRAN.R-project.org/package=openCR/

Efford, M. G. and Fletcher, D. (2024)  The effect of spatial overdispersion on confidence intervals for population density estimated by spatially explicit capture--recapture. bioRxiv DOI: 10.1101/2024.03.12.584742. 

Saura, S., and Martínez-Millán, J. (2000) Landscape patterns simulation with a modified random clusters method. *Landscape Ecology* **15**, 661--678.

Schlather, M., Malinowski, A., Menck, P. J., Oesting, M., and Strokorb, K. (2015) Analysis, simulation and prediction of multivariate random fields with package RandomFields. *Journal of Statistical Software* **63**, 1--25. https://www.jstatsoft.org/v63/i08/

# Appendix 1. Simulation summaries {#appendix1}

## No model

```{r summarynprint, eval = TRUE}
summary_n(sims1) # LGCP Poisson N(A)
summary_n(sims2) # Thomas Poisson N(A)
summary_n(sims3) # Random habitat Poisson N(A)

summary_n(sims1f) # LGCP fixed N(A) 
summary_n(sims2f) # Fixed cluster process
summary_n(sims3f) # Random habitat fixed N(A)
```

## Model fitted

Summarise relative to local density --
```{r summaryMprint1, eval = TRUE}
summary_M(sims1M) # LGCP Poisson N(A)
summary_M(sims2M) # Thomas Poisson N(A)
summary_M(sims3M) # Random habitat Poisson N(A)

summary_M(sims1fM) # LGCP fixed N(A) 
summary_M(sims2fM) # Fixed cluster process
summary_M(sims3fM) # Random habitat fixed N(A)
```

Summarise relative to global density --
```{r summaryMprint2, eval = TRUE}
summary_M(sims1M, true = 2844.44) # LGCP Poisson N(A)
summary_M(sims2M, true = 2844.44) # Thomas Poisson N(A)
summary_M(sims3M, true = 2844.44) # Random habitat Poisson N(A)
```

## Model fitted, conditional likelihood

```{r summaryMCLprint, eval = TRUE}
summary_MCL(sims1MCL) # LGCP Poisson N(A)
summary_MCL(sims2MCL) # Thomas Poisson N(A)
summary_MCL(sims3MCL) # Random habitat Poisson N(A)
```

## Model fitted, conditional likelihood, complete cohesion

```{r cohesion2, eval = TRUE}
summary_MCL(sims2CCL, true = 2844.44)   # Thomas cluster process
summary_MCL(sims2CfCL, true = 2844.44)  # fixed cluster process
```

<!-- # Appendix 2. Multi-session overdispersion. {#appendix2} -->

<!-- Experimental code to simulate repeated sampling of the same population. -->

<!-- WHAT ABOUT FIXED-N(A)? -->

<!-- ```{r simsmulti1, message = FALSE, cache = TRUE, warning = FALSE, eval = FALSE} -->
<!-- baseargs <- list( -->
<!-- 	D         = local$D,  -->
<!-- 	core      = local$mask, -->
<!-- 	buffer    = 0,    # uses bounding box of mask -->
<!-- 	model2D   = "poisson", -->
<!-- 	nsessions = 10, -->
<!-- 	details   = list(lambda = 1, phi = 1, movemodel = 'static')) -->
<!-- popargsmulti <-  rep(list(baseargs), 3) -->
<!-- popargsmulti[[1]][['details']]$lambda <- NULL -->
<!-- popargsmulti[[3]][['details']]$movemodel <- "IND" -->
<!-- names(popargsmulti) <- c('poisson','constant','independent') -->
<!-- sapply(popargsmulti[2:3], '[[', 'details') -->

<!-- ex_n <- function(CH) sapply(CH, nrow) -->
<!-- ex_M <- function(fit) predict(fit)[[1]] -->
<!-- ex_MCL <- function(fit) derived(fit) -->

<!-- simsMulti_n <- run_all( -->
<!-- 	nrepl      = 10000,  -->
<!-- 	popargs    = popargsmulti,  -->
<!-- 	fit        = FALSE,  -->
<!-- 	extractfn  = ex_n,  -->
<!-- 	seed       = 97531, -->
<!-- 	byscenario = TRUE)   -->

<!-- for (i in 1:3) popargsmulti[[i]]$Ndist <- "fixed" -->

<!-- simsMulti_nf <- run_all( -->
<!-- 	nrepl      = 10000,  -->
<!-- 	popargs    = popargsmulti,  -->
<!-- 	fit        = FALSE,  -->
<!-- 	extractfn  = ex_n,  -->
<!-- 	seed       = 97531,  -->
<!-- 	byscenario = TRUE)   -->

<!-- save(simsMulti_n, simsMulti_nf, file = 'simsMulti_n.RData') -->

<!-- for (i in 1:3) popargsmulti[[i]]$Ndist <- "poisson" -->

<!-- simsMulti_M <- run_all( -->
<!-- 	nrepl      = 1000,  -->
<!-- 	popargs    = popargsmulti[1:2],  -->
<!-- 	fit        = TRUE,  -->
<!-- 	extractfn  = ex_M, -->
<!-- 	seed       = 97531,  -->
<!-- 	byscenario = FALSE -->
<!-- )   -->

<!-- simsMulti_MCL <- run_all( -->
<!-- 	nrepl      = 100,  -->
<!-- 	popargs    = popargsmulti[2],  -->
<!-- 	fit        = TRUE,  -->
<!-- 	CL         = TRUE, -->
<!-- 	extractfn  = ex_MCL, -->
<!-- 	seed       = 97531, -->
<!-- 	byscenario = FALSE -->
<!-- )   -->
<!-- # save(simsMulti_n, simsMulti_nf, simsMulti_M, simsMulti_MCL, file = 'extra/simsMulti.RData') -->
<!-- # load(file = 'extra/simsMulti.RData') -->
<!-- fn <- function(x) c(var1 = var(x[,1]), varwithin = mean(apply(x,1,var)),  -->
<!-- 					varsum = var(apply(x,1,sum)),  -->
<!-- 					nbar = mean(apply(x,1,sum))) -->
<!-- sapply(simsMulti_n$output, fn) -->
<!-- #                 1         2         3 -->
<!-- # var1       181.38   180.651   179.039 -->
<!-- # varwithin  180.09    13.896    53.023 -->
<!-- # varsum    1813.46 16824.539 13230.299 -->

<!-- sapply(simsMulti_nf$output, fn) -->
<!-- #                 1        2       3 -->
<!-- # var1       53.961   52.042  53.127 -->
<!-- # varwithin  53.562   14.030  53.097 -->
<!-- # varsum    529.535 3934.999 528.590 -->

<!-- load('d:/density communication/overdispersion/matrix/simsMulti_M.RDATA') -->
<!-- summary(simsMulti_M)        -->


<!-- # run.scenarios(nrepl = nrepl, scenarios = scen, trapset = .local$traps,  -->
<!-- #     maskset = .local$mask, pop.args = popargs, CH.function = CH.function,  -->
<!-- #     det.args = detargs, fit = fit, fit.args = fitargs, extractfn = extractfn,  -->
<!-- #     ncores = ncores, byscenario = byscenario, seed = seed) -->
<!-- #  -->
<!-- # Replicates    1000  -->
<!-- # Started       10:22:13 08 Dec 2023  -->
<!-- # Run time      2973  minutes  -->
<!-- # Output class  selectedstatistics  -->
<!-- #  -->
<!-- # $constant -->
<!-- #                        value -->
<!-- # trapsindex                 1 -->
<!-- # noccasions                 5 -->
<!-- # nrepeats                   1 -->
<!-- # D           2844.44444444444 -->
<!-- # lambda0                  0.5 -->
<!-- # sigma                      1 -->
<!-- # detectfn                  14 -->
<!-- # recapfactor                1 -->
<!-- # detindex                   1 -->
<!-- # fitindex                   1 -->
<!-- # maskindex                  1 -->
<!-- #  -->
<!-- # $varying -->
<!-- #  scenario popindex -->
<!-- #         1        1 -->
<!-- #         2        2 -->
<!-- #         3        3 -->
<!-- #  -->
<!-- # $detectors -->
<!-- #  trapsindex trapsname -->
<!-- #           1    traps1 -->
<!-- #  -->
<!-- # $pop.args -->
<!-- #  popindex      D core buffer model2D nsessions                         details -->
<!-- #         1 2844.4 core      0 poisson        10          phi=1,movemodel=static -->
<!-- #         2 2844.4 core      0 poisson        10 lambda=1,phi=1,movemodel=static -->
<!-- #         3 2844.4 core      0 poisson        10    lambda=1,phi=1,movemodel=IND -->
<!-- #  -->
<!-- # $det.args -->
<!-- #  detindex savepopn -->
<!-- #         1     TRUE -->
<!-- #  -->
<!-- # $fit.args -->
<!-- #  fitindex detectfn mask    CL start              details -->
<!-- #         1      HHN mask FALSE       distribution=poisson -->
<!-- #  -->
<!-- # OUTPUT -->
<!-- #  -->
<!-- # $1 -->
<!-- #  1  -->
<!-- #                 n       mean      se -->
<!-- # estimate    1000 2842.08711 2.15148 -->
<!-- # SE.estimate 1000   67.32022 0.02589 -->
<!-- # lcl         1000 2713.17595 2.10120 -->
<!-- # ucl         1000 2977.12416 2.20182 -->
<!-- # RB          1000   -0.00083 0.00076 -->
<!-- # RSE         1000    0.02369 0.00001 -->
<!-- # COV         1000    0.94100 0.00745 -->
<!-- #  -->
<!-- # $2 -->
<!-- #  2  -->
<!-- #                 n      mean      se -->
<!-- # estimate    1000 2849.2756 6.35590 -->
<!-- # SE.estimate 1000   67.3603 0.07530 -->
<!-- # lcl         1000 2720.2852 6.20858 -->
<!-- # ucl         1000 2984.3905 6.50323 -->
<!-- # RB          1000    0.0017 0.00223 -->
<!-- # RSE         1000    0.0237 0.00003 -->
<!-- # COV         1000    0.4700 0.01579 -->
<!-- #  -->
<!-- # $3 -->
<!-- #  3  -->
<!-- #                n       mean      se -->
<!-- # estimate    1000 2846.88389 5.78165 -->
<!-- # SE.estimate 1000   67.35045 0.06864 -->
<!-- # lcl         1000 2717.91375 5.64737 -->
<!-- # ucl         1000 2981.98049 5.91597 -->
<!-- # RB          1000    0.00086 0.00203 -->
<!-- # RSE         1000    0.02371 0.00002 -->
<!-- # COV         1000    0.51800 0.01581 -->

<!-- # open population simulations -->
<!-- # rerun with 200 replicates 2023-12-12;  -->
<!-- library(openCR) -->
<!-- detargs <- list(traps = local$traps, noccasions = local$noccasions,  -->
<!-- 				detectfn = 'HHN', detectpar = local$detectpar) -->
<!-- fitargs <- list(detectfn = 'HHN', mask = local$mask, type = 'JSSAsecrD', -->
<!-- 				model = list(phi~1, D~1), fixed = list(phi=1,f=0)) -->
<!-- # Ndist poisson -->
<!-- opensims3 <- mapply(runsim.spatial, popargs = popargsmulti[2],  -->
<!-- 	MoreArgs = list (nrepl = 200, seed = NULL, ncores = 24, detargs = detargs, -->
<!-- 		fitargs = fitargs, extractfn = predict), SIMPLIFY = FALSE) -->
<!-- save(opensims3, file = 'opensims3.RData') -->

<!-- load('d:/density communication/overdispersion/matrix/opensims3.RDATA') -->
<!-- get <- function(sims = opensims, stat = 'estimate', scen=1) { -->
<!-- 	unlist(sapply(sims[[scen]], function(y) y$D[1,])[stat,])	 -->
<!-- }  -->
<!-- sumo <- function (sims) { -->
<!-- 	c(COV = mean((get(sims, 'lcl') < 2844.44) & (get(sims, 'ucl') >2844.44)), -->
<!-- 	  RSE = mean(get(sims, 'SE.estimate') / get(sims, 'estimate')), -->
<!-- 	  RB = mean((2844.44 - get(sims, 'estimate')) / 2844.44)) -->
<!-- } -->
<!-- sumo(opensims3) -->
<!--  #      COV       RSE        RB  -->
<!--  # 0.915000  0.068259 -0.003749  -->
<!-- ``` -->

